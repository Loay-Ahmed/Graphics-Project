// test.cpp : Defines the entry point for the application.
//

#include "framework.h"
#include <Windows.h>
#include <math.h>
#include <list>

int Round(double x)
{
    return (int)(x + 0.5);
}

template <typename type>
void swap(type& n1, type& n2)
{
    type s = n1;
    n1 = n2;
    n2 = s;
}

void LineBresenham(HDC hdc, int x1, int y1, int x2, int y2, COLORREF c) {
    int dx = abs(x2 - x1);
    int dy = abs(y2 - y1);
    int sx = (x1 < x2) ? 1 : -1;
    int sy = (y1 < y2) ? 1 : -1;
    int err = dx - dy;

    while (true) {
        SetPixel(hdc, x1, y1, c);
        if (x1 == x2 && y1 == y2) break;
        int e2 = 2 * err;
        if (e2 > -dy) {
            err -= dy;
            x1 += sx;
        }
        if (e2 < dx) {
            err += dx;
            y1 += sy;
        }
    }
}

struct point
{
    double x, y;
    point() : x(0), y(0) {}
};

typedef std::list<int> edgetable[800]; // Linked list for x-coordinates per scanline

void init(edgetable tbl)
{
    for (int i = 0; i < 800; i++)
    {
        tbl[i].clear();
    }
}

void edge2table(point v1, point v2, edgetable tbl)
{
    if (v1.y == v2.y) return; // Skip horizontal edges
    if (v1.y > v2.y) { swap(v1, v2); } // Ensure v1.y < v2.y
    int y = (int)ceil(v1.y);
    double x = v1.x;
    double minv = (v2.x - v1.x) / (v2.y - v1.y);
    while (y < v2.y)
    {
        if (y >= 0 && y < 800) { // Bounds check
            tbl[y].push_back(Round(x));
        }
        y++;
        x += minv;
    }
}

void polygon2table(point p[], int n, edgetable tbl)
{
    point v1 = p[n - 1];
    for (int i = 0; i < n; i++)
    {
        point v2 = p[i];
        edge2table(v1, v2, tbl);
        v1 = p[i];
    }
}

void table2screen(HDC hdc, edgetable tbl, COLORREF c)
{
    for (int i = 0; i < 800; i++)
    {
        if (!tbl[i].empty())
        {
            // Sort x-coordinates for the scanline
            tbl[i].sort();
            // Draw between pairs of x-coordinates
            auto it = tbl[i].begin();
            while (it != tbl[i].end())
            {
                int x1 = *it;
                ++it;
                if (it == tbl[i].end()) break;
                int x2 = *it;
                ++it;
                LineBresenham(hdc, x1, i, x2, i, c);
            }
        }
    }
}

void nonConvexFill(HDC hdc, point p[], int n, COLORREF c)
{
    edgetable tbl;
    init(tbl);
    polygon2table(p, n, tbl);
    table2screen(hdc, tbl, c);
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT m, WPARAM wp, LPARAM lp)
{
    static point points[4];
    static int count = 0;
    HDC hdc;

    switch (m)
    {
    case WM_LBUTTONDOWN:
    {
        int x = LOWORD(lp);
        int y = HIWORD(lp);
        if (count < 4)
        {
            points[count].x = x;
            points[count].y = y;
            count++;
        }

        if (count == 4)
        {
            hdc = GetDC(hwnd);
            nonConvexFill(hdc, points, 4, RGB(0, 0, 255)); // Blue fill
            ReleaseDC(hwnd, hdc);
            count = 0;
        }
    }
    break;

    case WM_CLOSE:
        DestroyWindow(hwnd); break;
    case WM_DESTROY:
        PostQuitMessage(0); break;
    default:
        return DefWindowProc(hwnd, m, wp, lp);
    }
    return 0;
}

int APIENTRY WinMain(HINSTANCE hi, HINSTANCE pi, LPSTR cmd, int nsh)
{
    WNDCLASS wc = {};
    wc.hbrBackground = (HBRUSH)GetStockObject(LTGRAY_BRUSH);
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon = LoadIcon(NULL, IDI_WINLOGO);
    wc.lpszClassName = L"MyClass";
    wc.lpfnWndProc = WndProc;
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.hInstance = hi;
    RegisterClass(&wc);

    HWND hwnd = CreateWindow(L"MyClass", L"Hello World!", WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
        NULL, NULL, hi, NULL);

    ShowWindow(hwnd, nsh);
    UpdateWindow(hwnd);

    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0) > 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return 0;
}
